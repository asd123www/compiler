// use std::str::FromStr;
use crate::ast::*;

// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
    // 跳过空白符和注释
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^\n\r]*[\n\r]*\*/" => {},
    // 剩下的情况采用默认方式处理
    _
}

// 定义 CompUnit, 其返回值类型为 String
// parser 在解析完成后的行为是返回 FuncDef 的值
pub CompUnit: CompUnit = {
    <func_def: FuncDef> => CompUnit{func_def},
}


FuncDef: FuncDef = {
  <func_type: FuncType> <ident: Ident> "(" ")" <block: Block> => {
    FuncDef { <> }
  }
}

FuncType: FuncType = "int" => FuncType::Int;

// Block         ::= "{" {BlockItem} "}";
Block: Block = {
    "{" <mut items: (<BlockItem>)*> "}" => Block {items},   
}

// BlockItem     ::= Decl | Stmt;
BlockItem: BlockItem = {
    <decl: Decl> => BlockItem::Decl(decl),
    <stmt: Stmt> => BlockItem::Stmt(stmt),
}

// Stmt ::= LVal "=" Exp ";"
//        | [Exp] ";"
//        | Block
//        | "return" [Exp] ";";
Stmt: Stmt = {
    "return" <exp: Exp> ";" => Stmt::RetExp(exp),
    <lval: LVal> "=" <exp: Exp> ";" => Stmt::LvalExp(lval, exp),
    <exp: Exp> ";" => Stmt::SingleExp(exp),
    <block: Block> => Stmt::Block(block),
    ";" => Stmt::ZeroExp(),
}










// ------------------------------ Variable ------------------------------------------

// LVal          ::= IDENT;
LVal: LVal = {
    <ident: Ident> => LVal {ident}, 
}

// Decl          ::= ConstDecl | VarDecl;
Decl: Decl = {
    <constdecl: ConstDecl> => Decl::Constdecl(constdecl),
    <vardecl: VarDecl> => Decl::Vardecl(vardecl),
}

// ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
ConstDecl: ConstDecl = {
    "const" <btype: BType> <def: ConstDef> <mut constdefs: ("," <ConstDef>)*> ";"  => {
        constdefs.insert(0, def); // def is the first.
        ConstDecl {btype, constdefs}
    },
}

// VarDecl       ::= BType VarDef {"," VarDef} ";";
VarDecl: VarDecl = {
    <btype: BType> <def: VarDef> <mut vardefs: ("," <VarDef>)*> ";" => {
        vardefs.insert(0, def);
        VarDecl {btype, vardefs}
    }
}

// BType         ::= "int";
BType: BType = "int" => BType::Int;


// ConstDef      ::= IDENT "=" ConstInitVal;
ConstDef: ConstDef = {
    <ident: Ident> "=" <constinitval: ConstInitVal> => ConstDef{ident, constinitval},
}
// VarDef        ::= IDENT | IDENT "=" InitVal;
VarDef: VarDef = {
    <ident: Ident> => VarDef::Ident(ident),
    <ident: Ident> "=" <initval: InitVal> => VarDef::Identinitval(ident, initval),
}


// ConstInitVal  ::= ConstExp;
ConstInitVal: ConstInitVal = {
    <constexp: ConstExp> => ConstInitVal{constexp},
}

// InitVal       ::= Exp;
InitVal: InitVal = {
    <exp: Exp> => InitVal{exp},
}




// ------------------------------ Expression ------------------------------------------

// ConstExp      ::= Exp;
ConstExp: ConstExp = {
    <exp: Exp> => ConstExp{exp},
}


// LOrExp
Exp: Exp = {
    <lorexp: LOrExp> => Exp{lorexp},
}

// PrimaryExp    ::= "(" Exp ")" | LVal | Number;
PrimaryExp: PrimaryExp = {
    "(" <exp: Exp> ")" => PrimaryExp::Exp(Box::new(exp)),
    <lval: LVal> => PrimaryExp::Lval(lval),
    <num: Number> => PrimaryExp::Num(num),
}

// UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
UnaryExp: UnaryExp = {
    <primaryexp: PrimaryExp> => UnaryExp::Primaryexp(primaryexp),
    <unaryop: UnaryOp> <unaryexp: UnaryExp> => UnaryExp::Unaryexp(unaryop, Box::new(unaryexp)), 
}

// UnaryOp     ::= "+" | "-" | "!";
UnaryOp: UnaryOp = {
    "+" => UnaryOp::Add,
    "-" => UnaryOp::Sub,
    "!" => UnaryOp::Not,
}

// MulExp      ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
MulExp: MulExp = {
    <unaryexp: UnaryExp> => MulExp::Unaryexp(unaryexp),
    <mulexp: MulExp> "*" <unaryexp: UnaryExp> => MulExp::Mulexp(Box::new(mulexp), unaryexp, "mul".to_string()),
    <mulexp: MulExp> "/" <unaryexp: UnaryExp> => MulExp::Divexp(Box::new(mulexp), unaryexp, "div".to_string()),
    <mulexp: MulExp> "%" <unaryexp: UnaryExp> => MulExp::Modexp(Box::new(mulexp), unaryexp, "mod".to_string()),
}

// AddExp      ::= MulExp | AddExp ("+" | "-") MulExp;
AddExp: AddExp = {
    <mulexp: MulExp> => AddExp::Mulexp(mulexp),
    <addexp: AddExp> "+" <mulexp: MulExp> => AddExp::Addexp(Box::new(addexp), mulexp, "add".to_string()),
    <addexp: AddExp> "-" <mulexp: MulExp> => AddExp::Subexp(Box::new(addexp), mulexp, "sub".to_string()),
}

// RelExp      ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: RelExp = {
    <addexp: AddExp> => RelExp::Addexp(addexp),
    <relexp: RelExp> "<" <addexp: AddExp>  => RelExp::Ltexp(Box::new(relexp), addexp, "lt".to_string()),
    <relexp: RelExp> ">" <addexp: AddExp>  => RelExp::Gtexp(Box::new(relexp), addexp, "gt".to_string()),
    <relexp: RelExp> "<=" <addexp: AddExp> => RelExp::Leexp(Box::new(relexp), addexp, "le".to_string()),
    <relexp: RelExp> ">=" <addexp: AddExp> => RelExp::Geexp(Box::new(relexp), addexp, "ge".to_string()),
}

// EqExp       ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: EqExp = {
    <relexp: RelExp> => EqExp::Relexp(relexp),
    <eqexp: EqExp> "==" <relexp: RelExp> => EqExp::Eqexp(Box::new(eqexp), relexp, "eq".to_string()),
    <eqexp: EqExp> "!=" <relexp: RelExp> => EqExp::Neqexp(Box::new(eqexp), relexp, "ne".to_string()),
}

// LAndExp     ::= EqExp | LAndExp "&&" EqExp;
LAndExp: LAndExp = {
    <eqexp: EqExp> => LAndExp::Eqexp(eqexp),
    <landexp: LAndExp> "&&" <eqexp: EqExp> => LAndExp::Andexp(Box::new(landexp), eqexp),
}

// LOrExp      ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: LOrExp = {
    <landexp: LAndExp> => LOrExp::Landexp(landexp),
    <lorexp: LOrExp> "||" <landexp: LAndExp> => LOrExp::Orexp(Box::new(lorexp), landexp),
}

// Number      ::= INT_CONST;
Number: i32 = <num: IntConst> => <>;


// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
// 关于尖括号到底代表什么, 请 RTFM
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();


// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}